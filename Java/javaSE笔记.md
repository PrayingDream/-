<h4 align = "center">SublimeText的使用</h4>

##### .java编译

​	javac *.java

##### .class运行

​	java *.class

记得保存后再编译

<h4 align = "center">
    Dos命令
</h4>

| dir              | dir 绝对路径 |
| ---------------- | ------------ |
| 查看当前目录内容 | 查看路径内容 |

| cd /D 磁盘: | cd 绝对路径/相对路径 | cd ..      | cd \       |
| ----------- | -------------------- | ---------- | ---------- |
| 切换磁盘    | 切换当前盘符的目录   | 返回上一级 | 切换根目录 |

| tree 目录                    | cls  | exit |
| ---------------------------- | ---- | ---- |
| 查看指定目录下所有的子级目录 | 清屏 | 退出 |

| md       | rd       | copy     | del      | echo           | type       | move |
| -------- | -------- | -------- | -------- | -------------- | ---------- | ---- |
| 创建目录 | 删除目录 | 拷贝文件 | 删除文件 | 输入内容到文件 | 输入空文件 | 剪切 |



<h4 align = "center">
    java语法
</h4>

##### 转义字符

| \t     | \n     | \\\\   | \\\"  | \\\'  | \r   |
| :----- | ------ | ------ | ----- | ----- | ---- |
| 制表符 | 换行符 | " \\ " | " " " | " ' " | 回车 |

##### 注释

| 单行注释           | 多行注释                      | 文档注释    |
| ------------------ | ----------------------------- | ----------- |
| " // "  Ctrl + "/" | " /*  */"  Ctrl + Shift + "/" | javadoc标签 |

##### 变量

变量 = 变量名 + 值 + 数据类型;

同一作用域内，变量不能重名

##### 数据类型

<table>
    <tr>
        <td align="center" colspan="4">基本数据类型</td>
        <td align="center" colspan="3">引用数据类型</td>
    </tr>
    <tr>
        <td align="center" colspan="2">数值型</td>
        <td align="center" rowspan="2">字符型</td>
        <td align="center" rowspan="2">布尔型</td>
        <td align="center" rowspan="2">类(class)</td>
        <td align="center" rowspan="2">接口(interface)</td>
        <td align="center" rowspan="2">数组([])</td>
    </tr>
    <tr>
        <td align="center">整数类型</td>
        <td align="center">浮点(小数)类型</td>
    </tr>
    <tr>
    	<td>byte[1],short[2],int[4],long[8]</td>
        <td>float[4],double[8]</td>
        <td>char[2]</td>
        <td>boolean[1]</td>
    </tr>
</table>
##### 基本数据类型转换

![image-20240616134145244](https://s2.loli.net/2024/06/16/idbESlZoUcr4RTg.png)

##### 基本数据类型转化为字符串

```java
// 基本数据类型->String
int n1= 100;
float f1 = 1.1f;
double d1 = 4.5;
boolean b1 = true;
String	s1 = n1 + "";
String	s2 = f1 + "";
String	s3 = d1 + "";
String	s4 = b1 + "";
```

##### 字符串转化为基本数据类型

```java
// String->基本数据类型
String s1 = "12";
String s2 = "true";
int n1 = Integer.parseInt(s1);
double d1 = Double.parseDouble(s1);
float f1 = Float.parseFloat(s1);
long l1 = Long.parseLong(s1);
byte b1 = Byte.parseByte(s1);
boolean bool1 = Boolean.parseBoolean(s2);
```

##### 运算符的优先级

| 优先级 |                            运算符                            |  结合性  |
| :----: | :----------------------------------------------------------: | :------: |
|   1    |                         ( )　[ ] 　.                         | 从左到右 |
|   2    |                        ! 　~　 ++　 –                        | 从右到左 |
|   3    |                          *　 /　 %                           | 从左到右 |
|   4    |                            +　 -                             | 从左到右 |
|   5    |                        << 　>>　 >>>                         | 从左到右 |
|   6    |                 < 　<=　 > 　>=　 instanceof                 | 从左到右 |
|   7    |                           == 　!=                            | 从左到右 |
|   8    |                              &                               | 从左到右 |
|   9    |                              ^                               | 从左到右 |
|   10   |                              \|                              | 从左到右 |
|   11   |                              &&                              | 从左到右 |
|   12   |                             \|\|                             | 从左到右 |
|   13   |                             ? :                              | 从左到右 |
|   14   | = 　+= 　-= 　*=　 /=　 %=　 &=　 \|=　 ^=　 ~= 　<<= 　>>=　 >>>= | 从右到左 |
|   15   |                              ，                              | 从右到左 |

##### 标识符命名规范

1.包名:多单词组成时所有字母都小写:aaa.bbb.ccc //例如:com.hsp.crm

2.类名、接口名:多单词组成时，所有单词的首字母大写:XxxYyyZzz //例如:TankShotGame[大驼峰]

3.变量名、方法名:多单词组成时,第一个单词首字母小写，第二个单词开始每个单词首字母大写:xxxYyyZzz[小驼峰]

4.常量名:所有字母都大写。多单词时每个单词用下划线连接:XXX_YYY_ZZZ //比如TAX_RATE

##### 键盘输入

Scanner类

```java
Scanner scanner = new Scanner(System.in);  // 创建对象
```

##### 进制开头表示

| 二进制 | 十进制 | 八进制 | 十六进制 |
| ------ | ------ | ------ | -------- |
| 0B/0b  |        | 0      | 0x/0X    |

##### 原码、反码、补码

1.二进制最高位是符号位:0代表正数，1代表负数

2.正数的原码、反码、补码都一样

3.负数的反码=它的原码符号位不变，其他位取反

4.负数的补码=他的反码+1，负数的反码= 负数的补码-1

5.0的反码补码都是0

6.java没有无符号数，换言之，java中的数字都是有符号的

7.在计算机运动的时候，都是以补码的方式来运算的

8.当我们看运算结果的时候，要看它的原码

##### 位运算符

按位与& :两位全为1，结果为1，否则为0

按位或| :两位有一个1，结果为1，否则为0

按位异或^ :两位一个为0，一个为1，结果为1，否则为0

按位取反~ : 0->1 , 1->0

##### 方法的重载

java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！

##### 可变参数

java允许将同一个类中的多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现。

1)可变参数的实参也可以是数组。

2)可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后。

3)一个形参列表中只能出现一个可变参数。

```java
// 访问修饰符 返回类型 方法名(数据类型... 形参名){}
// 求和方法
public int sum(int num, int... nums){ // nums可以直接当做数组使用
    int res = 0;
    for(int i = 0; i<nums.length; i++){
        res += nums[i];
    }
    return res;
}
```

##### 构造方法/构造器

构造方法又叫构造器(constructor)，是类的一种特殊的方法，他的主要作用是完成对新对象的初始化。			

1)构造器没有返回值

2)方法名和类名必须一样

3)构造器的调用由系统完成

4)一个类可以定义多个不同的构造器，即构造器重载

5)一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式定义一下。

```java
// [修饰符] 方法名(形参列表){方法体}
class Person{
    String name;
    int age;
    public Person(String pName, int pAge){
    	name = pName;
        age = pAge;
    }
    public Person(){ // 显示定义无参构造器
        
    }
}
```

##### this关键字

哪个对象调用，this就代表哪个对象。

在构造器中访问另一个构造器 this(参数列表)  ，必须放在第一条语句。

##### 包

###### 命名规则：

只能包含数字、字母、下划线、小圆点.，但不能用数字开头，不能是关键字或保留字。

###### 命名规范

一般是小写字母+小圆点

com.公司名.项目名.业务模块名

##### 访问修饰符

1.公开级别:用public修饰，对外公开。

2.受保护级别:用protected修饰，对子类和同一个包中的类公开。

3.默认级别:没有修饰符号.向同一个包的类公开。

4.私有级别:用private修饰，只有类本身可以访问，不对外公开。

##### 封装

###### 封装介绍

封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。

###### 封装的好处

1)隐藏实现细节

2)可以对数据进行验证，保证安全合理

###### 封装的实现步骤

1)将属性进行私有化private

2)提供一个公共的set方法，用于对属性判断并赋值

```java
public void setXxx(类型 参数名){
    // 加入属性验证的也不逻辑
    属性 = 参数名;
}
```

3)提供一个公共的get方法，用于获取属性的值

```java
public XX getXxx(){
    return xx;
}
```

可以将set方法写在构造器中

```java
public Person(String name, int age, double salary) {
//        this.name = name;
//        this.age = age;
//        this.salary = salary;
        //将set方法写在构造器中
        setName(name);
        setAge(age);
        setSalary(salary);
    }
```

##### 继承

![image-20240624024735893](https://s2.loli.net/2024/06/24/BwUP4OkZQfKLvJ9.png)

###### 继承的基本语法

```java
class 子类 extends 父类{}
```

1)子类会自动拥有父类定义的属性和方法

2)父类又叫超类，基类

3)子类又叫派生类

###### 继承的细节

1.子类继承了所有的属性和方法，但是有属性和方法不能再子类直接访问，要通过公共的方法去访问。

2.子类必须调用父类的构造器，完成父类的初始化。

3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器(super();)，如果父类没有提供无参构器，则必须再子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。

4.如果希望指定去调用父类的某个构造器，则显式的调用一下:super(参数列表);

5.super在使用的时候必须放在子类构造器的第一行(super只能在构造器中使用)。

6.super()(调用父类中的构造器)和this()(调用本类中的构造器)都只能放在构造器的第一行，因此不能共存。

7.java所有类都是Object类的子类，object是所有类的基类。

8.父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)。

9.子类最多继承一个父类(指直接继承)，即java中是单继承机制。(让B类继承A类，C类再继承B类，就可以让C类同时继承A类和B类)。

10.不能滥用继承，子类和父类之间必须要满足is-a的逻辑关系。

##### super关键字

###### 基本介绍

super表示父类的引用，用于访问父类的属性、方法、构造器

###### 基本语法

1.访问父类的属性但不能访问父类的private属性

```java
super.属性名;
```

2.访问父类的方法，但不能访问父类的private方法

```java
super.方法名(参数列表);
```

3.访问父类的构造器

```java
super(参数列表);//只能放在构造器的第一句，只能出现一句!
```

###### super便利/细节

1.调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化)

2.当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！

```java
class A{
    public void say() {
        System.out.println("A say~~");
    }
}
class B entends A {
    public void test() {
        //say();
        //this.say();
        super.say();
    }
}
```

3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。A -> B -> C

###### super和this的比较

![image-20240625012151808](https://s2.loli.net/2024/06/25/twgzldNXyLHPnsE.png)

##### 方法的重写

###### 基本介绍

方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。

###### 注意事项和使用细节

方法重写也叫方法覆盖，需要满足下面的条件

1.子类的方法参数，方法名称要和父类方法的参数，方法名称完全一样。

2.子类方法的返回类型和父类返回类型一样，或者是父类返回类型的子类.

3.子类方法不能缩小父类方法的访问权限.

###### 方法重载(overload)和重写(override)的区别

![image-20240625014754307](https://s2.loli.net/2024/06/25/h4mROAldkyX2IWe.png)

##### 多态

###### 基本介绍

方法或对象具有多种形态。是面对对象的第三大特征，多态是建立在封装和继承基础之上的。

###### 具体体现

1.方法的多态
重写和重载就体现多态

2.对象的多态
1）一个对象的编译类型和运行类型可以不一致
2）编译类型在定义对象时，就确定了，不能改变
3）运行类型是可以变化的
4）编译类型看定义是 = 号的左边，运行类型看 = 号的右边

```java
//可以用父类引用指向子类对象
Animal animal = new Dog();
animal = new Cat();
```

###### 多态注意事项和细节讨论

多态的前提是：两个对象(类)存在继承关系

属性没有重写之说！属性的值看编译类型

instanceOf比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型

```java
BB bb = new BB();
System.out.println(bb instanceof BB);//true
System.out.println(bb instanceof AA);//true


class AA {} //父类
class BB entends AA {}//子类
```



###### 多态的向上转型

1)本质：父类的引用指向了子类的对象
2)语法：父类类型 引用名 = new 子类类型();
3)特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员(需遵循访问权限)，不能调用子类中特有的成员；最终运行效果看子类的具体实现！(子类中如果对父类方法进行重写，优先调用子类的方法)

###### 多态的向下转型

1)语法：子类类型 引用名 = (子类类型) 父类引用；
2)只能强转父类的引用，不能强转父类的对象
3)要求父类的引用必须指向的是当前目标类型的对象
4)可以调用子类类型中所有的成员

##### java的动态绑定机制

1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定

2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

##### 多态数组

数组的定义类型为父类类型，里面保存的实际元素类型为子元素类型

##### 多态参数

方法定义的参数类型为父类类型，实参类型语序为子类类型

##### Object类详解

###### ==和equals的对比

1.==：既可以判断基本类型，又可以判断引用类型
2.==：如果判断基本类型，判断的是值是否相等
3.==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象
4.equals：是Object类中的方法，只能判断引用类型。
5.默认判断的是地址是否相等，子类中往往重写该方法，用于判断内同是否相等。

###### hashCode()

1)提高具有哈希结构的容器的效率
2)两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
3)两个引用，如果指向的是不同对象，则哈希值是不一样的
4)哈希值主要是根据地址号来的，不能完全将哈希值等价于地址

###### toString()

默认返回:	全类名+@+哈希值的十六进制

重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式

当直接输出一个对象时，toString方法会被默认调用

###### finalize()

1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
2.什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法
3.垃圾回收机制的调用，是由系统来决定的，也可以通过System.gc()主动触发垃圾回收机制

##### 断点调试

断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug

F7(跳入)：跳入方法内
F8(跳过)：逐行执行代码
shift + F8：跳出方法
F9：执行到下一个断点

##### 类变量和类方法

